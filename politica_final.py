# Parametros calibrados:
# * Instancia 1:
#     * {'min_pedidos_salida': 17, 'porcentaje_reduccion_distancia': 31, 'max_puntos_eliminados': 14, 'x_minutos': 20, 'limite_area1': 128, 'limite_area2': 210, 'peso_min_pedidos': 1.4258208140237363, 'peso_ventana_tiempo': 1.7845358791509105, 'umbral_salida': 1.9097996396208297, 'tiempo_minimo_pickup': 39, 'max_aumento_distancia': 11, 'tiempo_necesario_pick_up': 1378, 'tiempo_restante_max': 111, 'max_aumento_distancia_delivery': 844}
#     * 
#     * {'min_pedidos_salida': 13, 'porcentaje_reduccion_distancia': 37, 'max_puntos_eliminados': 8, 'x_minutos': 59, 'limite_area1': 134, 'limite_area2': 186, 'peso_min_pedidos': 1.4345567915049973, 'peso_ventana_tiempo': 1.3588844137499472, 'umbral_salida': 1.3851690157693943, 'tiempo_minimo_pickup': 38, 'max_aumento_distancia': 20, 'tiempo_necesario_pick_up': 968, 'tiempo_restante_max': 9, 'max_aumento_distancia_delivery': 29}
#     * 
#     * {'min_pedidos_salida': 17, 'porcentaje_reduccion_distancia': 62, 'max_puntos_eliminados': 17, 'x_minutos': 56, 'limite_area1': 93, 'limite_area2': 270, 'peso_min_pedidos': 1.3683745561452805, 'peso_ventana_tiempo': 1.5087497070531928, 'umbral_salida': 1.609613386809045, 'tiempo_minimo_pickup': 26, 'max_aumento_distancia': 9, 'tiempo_necesario_pick_up': 1054, 'tiempo_restante_max': 137, 'max_aumento_distancia_delivery': 11}
# * Instancia 2:
#     * {'min_pedidos_salida': 14, 'porcentaje_reduccion_distancia': 36, 'max_puntos_eliminados': 7, 'x_minutos': 3, 'limite_area1': 134, 'limite_area2': 210, 'peso_min_pedidos': 1.9687142346197708, 'peso_ventana_tiempo': 1.1025506899704678, 'umbral_salida': 1.7115549689422893, 'tiempo_minimo_pickup': 18, 'max_aumento_distancia': 7, 'tiempo_necesario_pick_up': 1413, 'tiempo_restante_max': 130, 'max_aumento_distancia_delivery': 280}
#     * 
#     * {'min_pedidos_salida': 18, 'porcentaje_reduccion_distancia': 30, 'max_puntos_eliminados': 16, 'x_minutos': 2, 'limite_area1': 92, 'limite_area2': 213, 'peso_min_pedidos': 1.389935989337192, 'peso_ventana_tiempo': 0.8677152709217305, 'umbral_salida': 1.392232984569243, 'tiempo_minimo_pickup': 28, 'max_aumento_distancia': 9, 'tiempo_necesario_pick_up': 886, 'tiempo_restante_max': 101, 'max_aumento_distancia_delivery': 29}
#     * 
#     * {'min_pedidos_salida': 17, 'porcentaje_reduccion_distancia': 63, 'max_puntos_eliminados': 14, 'x_minutos': 27, 'limite_area1': 109, 'limite_area2': 199, 'peso_min_pedidos': 1.129656004873347, 'peso_ventana_tiempo': 0.6032264027418948, 'umbral_salida': 1.1825581718546028, 'tiempo_minimo_pickup': 17, 'max_aumento_distancia': 5, 'tiempo_necesario_pick_up': 1143, 'tiempo_restante_max': 100, 'max_aumento_distancia_delivery': 41}
# * Instancia 3:
#     * {'min_pedidos_salida': 1, 'porcentaje_reduccion_distancia': 54, 'max_puntos_eliminados': 6, 'x_minutos': 50, 'limite_area1': 119, 'limite_area2': 267, 'peso_min_pedidos': 0.5971182427582737, 'peso_ventana_tiempo': 0.713478246757084, 'umbral_salida': 1.011875143339422, 'tiempo_minimo_pickup': 31, 'max_aumento_distancia': 13, 'tiempo_necesario_pick_up': 824, 'tiempo_restante_max': 118, 'max_aumento_distancia_delivery': 491}
#     * 
#     * {'min_pedidos_salida': 5, 'porcentaje_reduccion_distancia': 63, 'max_puntos_eliminados': 9, 'x_minutos': 40, 'limite_area1': 144, 'limite_area2': 239, 'peso_min_pedidos': 1.2709372730059911, 'peso_ventana_tiempo': 1.5742119038813274, 'umbral_salida': 1.587618895342463, 'tiempo_minimo_pickup': 44, 'max_aumento_distancia': 14, 'tiempo_necesario_pick_up': 1272, 'tiempo_restante_max': 122, 'max_aumento_distancia_delivery': 19}
#     * 
#     * {'min_pedidos_salida': 19, 'porcentaje_reduccion_distancia': 67, 'max_puntos_eliminados': 13, 'x_minutos': 1, 'limite_area1': 140, 'limite_area2': 180, 'peso_min_pedidos': 0.7993143719423276, 'peso_ventana_tiempo': 0.8241533963555013, 'umbral_salida': 1.231678361485861, 'tiempo_minimo_pickup': 27, 'max_aumento_distancia': 8, 'tiempo_necesario_pick_up': 1405, 'tiempo_restante_max': 174, 'max_aumento_distancia_delivery': 82}
# * Instancia 4:
#     * {'min_pedidos_salida': 2, 'porcentaje_reduccion_distancia': 46, 'max_puntos_eliminados': 13, 'x_minutos': 8, 'limite_area1': 143, 'limite_area2': 232, 'peso_min_pedidos': 1.3650083117702956, 'peso_ventana_tiempo': 1.8548290102815066, 'umbral_salida': 1.5601612050582978, 'tiempo_minimo_pickup': 17, 'max_aumento_distancia': 12, 'tiempo_necesario_pick_up': 1294, 'tiempo_restante_max': 195, 'max_aumento_distancia_delivery': 1227}
#     * 
#     * {'min_pedidos_salida': 2, 'porcentaje_reduccion_distancia': 49, 'max_puntos_eliminados': 12, 'x_minutos': 37, 'limite_area1': 109, 'limite_area2': 235, 'peso_min_pedidos': 1.3462605634101168, 'peso_ventana_tiempo': 1.523125976294386, 'umbral_salida': 1.4604432560468708, 'tiempo_minimo_pickup': 37, 'max_aumento_distancia': 11, 'tiempo_necesario_pick_up': 1445, 'tiempo_restante_max': 54, 'max_aumento_distancia_delivery': 1436}
#     * 
#     * {'min_pedidos_salida': 15, 'porcentaje_reduccion_distancia': 68, 'max_puntos_eliminados': 11, 'x_minutos': 58, 'limite_area1': 141, 'limite_area2': 239, 'peso_min_pedidos': 1.9138181730131887, 'peso_ventana_tiempo': 1.8613353548514777, 'umbral_salida': 1.3676121600899114, 'tiempo_minimo_pickup': 33, 'max_aumento_distancia': 9, 'tiempo_necesario_pick_up': 1442, 'tiempo_restante_max': 166, 'max_aumento_distancia_delivery': 916}



import numpy as np
from ruteo import *
import pickle
import matplotlib.pyplot as plt
from funciones_caso_base import *


#Pasos a implementar forma inteligente y con un parametro modificable de priorizar los deliveries con los pick ups
#Forma inteligente de incertar un pick up a una ruta en movimiento
#Forma de descartar los pedidos de una ruta en caso de mejora
#Mejorar la iniciacion de la funcion para que esta se puedan modificar de forma intelegente los parametros

def separar_y_seleccionar_area(pedidos_disponibles):
    # Separar los pedidos según su área
    pedidos_area1 = [pedido for pedido in pedidos_disponibles if pedido.area == 1]
    pedidos_area2 = [pedido for pedido in pedidos_disponibles if pedido.area == 2]
    pedidos_area3 = [pedido for pedido in pedidos_disponibles if pedido.area == 3]

    # Calcular cuál área tiene más pedidos
    max_area = max(len(pedidos_area1), len(pedidos_area2), len(pedidos_area3))

    if max_area == len(pedidos_area1):
        return pedidos_area1
    elif max_area == len(pedidos_area2):
        return pedidos_area2
    else:
        return pedidos_area3


def flujo_ruteo(camion, simulacion, parametros):
    # 1. Obtener los pedidos disponibles
    pedidos_disponibles = simulacion.pedidos_disponibles

    # 3. Separar los pedidos según su área y seleccionar el área con más pedidos
    pedidos_a_rutear = separar_y_seleccionar_area(pedidos_disponibles)

    depot=[10000, 10000]
    # 4. Generar la ruta según los pedidos en el área con más pedidos
    ruta = generar_ruta(points, depot, camion, simulacion.minuto_actual, pedidos_a_rutear, parametros, tiempo_limite=180)


    # 7. Actualizar los pedidos entregados
    actualizar_estado_simulacion(simulacion, ruta)
    if len(ruta) <= 2:
        return

    # 8. Actualizar el camión con la nueva ruta
    tiempo_ruta = calcular_tiempo_ruta(ruta, camion.velocidad)
    camion.asignar_ruta(ruta, tiempo_ruta, simulacion.minuto_actual)
    # 9. Devolver la ruta y el tiempo de la ruta
    return ruta, tiempo_ruta


def asignar_area(punto, parametros):
    x, y = punto
    cx, cy = 10000, 10000  # Centro del mapa
    vector = np.array([x - cx, y - cy])
    angle = np.degrees(np.arctan2(vector[1], vector[0]))

    if angle < 0:
        angle += 360

    # Usar los dos parámetros de ángulo para definir los límites de las tres áreas
    limite_area1 = parametros["limite_area1"]
    limite_area2 = parametros["limite_area2"]

    if 0 <= angle < limite_area1:
        return 1  # Área 1
    elif limite_area1 <= angle < limite_area2:
        return 2  # Área 2
    else:
        return 3  # Área 3

# Función para actualizar el estado de la simulación, marcando los puntos de la ruta como visitados
def actualizar_estado_simulacion(simulacion, ruta):
    # Lista para almacenar los pedidos que se entregarán
    pedidos_a_entregar = []
    
    
    # Para cada punto en la ruta, buscar el pedido correspondiente en pedidos disponibles
    for punto in ruta:

        pedidos_en_punto = [pedido for pedido in simulacion.pedidos_disponibles if np.array_equal(pedido.coordenadas, punto)]
        pedidos_a_entregar.extend(pedidos_en_punto)

    index = []
    for i in range (len(pedidos_a_entregar)):
        index.append(i)

    arraival_times, _ = calculate_arrival_times(index, pedidos_a_entregar, [10000, 10000], ((25 * 1000) / 60), simulacion.minuto_actual, service_time=3)
    # Actualizar el estado de los pedidos y las listas de la simulación
    x = 0
    for pedido in pedidos_a_entregar:
        # Cambiar el estado del pedido a entregado
        minuto_entrega = arraival_times[x]
        pedido.entregar(minuto_entrega)
        # Mover el pedido a la lista de pedidos entregados
        simulacion.pedidos_entregados.append(pedido)
        x += 1

    # Remover los pedidos entregados de la lista de pedidos disponibles
    simulacion.pedidos_disponibles = [pedido for pedido in simulacion.pedidos_disponibles if pedido not in pedidos_a_entregar]

def simular_minuto_a_minuto(simulacion, camiones, parametros_ventana_1, parametros_ventana_2, parametros_ventana_3):
    # Inicia la simulación desde las 8:30 AM (minuto 630) hasta las 7:00 PM (1110 minutos)
    for minuto in range(520, 1020 + 1):
        simulacion.minuto_actual = minuto
        print(f"Minuto {minuto}: simulando...")

        if minuto <= 650:
            parametros = parametros_ventana_1
        elif 651 <= minuto <= 780:
            parametros = parametros_ventana_2
        else:
            parametros = parametros_ventana_3
        # Actualizar los pedidos disponibles minuto a minuto
        simulacion.revisar_pedidos_disponibles()


        # Actualizar tiempos de los camiones
        for camion in camiones:
            camion.actualizar_tiempo()
            
        # Evaluar si los camiones deben salir a rutear
        for camion in camiones:
            if evaluar_salida(camion, simulacion, parametros):
                # Gestionar el camión cuando sale a realizar una ruta
                flujo_ruteo(camion, simulacion, parametros)
        
        # Cada 30 minutos, calcular el porcentaje de beneficio captado
        if minuto % 30 == 0:
            beneficio_acumulado = simulacion.calcular_beneficio_acumulado()
            porcentaje_beneficio = simulacion.calcular_porcentaje_beneficio(beneficio_acumulado)
            simulacion.beneficio_por_intervalo.append((minuto, porcentaje_beneficio))

        # Avanza el minuto en la simulación
        simulacion.avanzar_minuto()
        simulacion.registrar_estado(camiones)
    
    print(len(simulacion.pedidos_entregados))
    print("Simulación finalizada.")
    

    for camion in camiones:
        tiempo_en_ruta = 0

        for ruta in camion.rutas:
            tiempo_en_ruta += calcular_tiempo_ruta(ruta, camion.velocidad)

        print(f"Camión {camion.id}:")
        print(f"Veces que realizó rutas: {len(camion.rutas)}")
        print(f"Tiempo total manejado: {tiempo_en_ruta / 60:.2f} horas")

    beneficio_total = calcular_beneficio(simulacion)
    distancia_total = calcular_distancia_total(camiones)

    print(f"Beneficio total: {beneficio_total}")
    print(f"Distancia total recorrida: {distancia_total} M")

    tiempos_respuesta = [pedido.tiempo_entrega for pedido in simulacion.pedidos_entregados if pedido.tiempo_entrega is not None]
    tiempo_respuesta_promedio = sum(tiempos_respuesta) / len(tiempos_respuesta)
    print(f"Tiempo de respuesta promedio: {tiempo_respuesta_promedio:.2f} minutos")


    # Contar la cantidad de pick-ups y deliveries realizados
    cantidad_pickups = sum(1 for pedido in simulacion.pedidos_entregados if pedido.indicador == 1)
    cantidad_deliveries = sum(1 for pedido in simulacion.pedidos_entregados if pedido.indicador == 0)

    # Imprimir el conteo de pick-ups y deliveries
    print(f"Cantidad de pick-ups realizados: {cantidad_pickups}")
    print(f"Cantidad de deliveries realizados: {cantidad_deliveries}")

    print()
    # Análisis dentro de rutas individuales y entre rutas del mismo camión
    # for camion in camiones:
    #     print(f"Analizando repeticiones para el Camión {camion.id}:")

    #     # Verificar repeticiones dentro de cada ruta
    #     for i, ruta in enumerate(camion.rutas):
    #         # Excluir el depósito del análisis
    #         puntos_unicos = set(tuple(punto) for punto in ruta if not np.array_equal(punto, [10000, 10000]))
    #         ruta_filtrada = [punto for punto in ruta if not np.array_equal(punto, [10000, 10000])]
    #         if len(puntos_unicos) < len(ruta_filtrada):
    #             print(f"  Ruta {i + 1} tiene puntos repetidos dentro de sí misma (excluyendo el depósito).")
    #         else:
    #             print(f"  Ruta {i + 1} no tiene puntos repetidos dentro de sí misma (excluyendo el depósito).")

    #     # Verificar repeticiones entre rutas
    #     puntos_todas_rutas = set()
    #     puntos_repetidos = set()
    #     for ruta in camion.rutas:
    #         for punto in ruta:
    #             if np.array_equal(punto, [10000, 10000]):
    #                 continue  # Ignorar el depósito
    #             punto_tuple = tuple(punto)
    #             if punto_tuple in puntos_todas_rutas:
    #                 puntos_repetidos.add(punto_tuple)
    #             else:
    #                 puntos_todas_rutas.add(punto_tuple)

    #     if puntos_repetidos:
    #         print(f"  Hay puntos repetidos entre rutas (excluyendo el depósito): {puntos_repetidos}")
    #     else:
    #         print("  No hay puntos repetidos entre rutas (excluyendo el depósito).")

    # # Comparación entre camiones
    # print("\nComparación de puntos entre camiones (excluyendo el depósito):")
    # puntos_por_camion = {}  # Diccionario para almacenar los puntos visitados por cada camión

    # # Recopilar puntos visitados por cada camión, excluyendo el depósito
    # for camion in camiones:
    #     puntos_visitados = set(tuple(punto) for ruta in camion.rutas for punto in ruta if not np.array_equal(punto, [10000, 10000]))
    #     puntos_por_camion[camion.id] = puntos_visitados

    # # Comparar puntos entre camiones
    # for id1, puntos_camion1 in puntos_por_camion.items():
    #     for id2, puntos_camion2 in puntos_por_camion.items():
    #         if id1 < id2:  # Evitar comparaciones duplicadas
    #             puntos_repetidos = puntos_camion1 & puntos_camion2  # Intersección de puntos
    #             if puntos_repetidos:
    #                 print(f"  Camión {id1} y Camión {id2} tienen puntos repetidos: {puntos_repetidos}")
    #             else:
    #                 print(f"  Camión {id1} y Camión {id2} no tienen puntos repetidos.")
    
    # Verificar si hay pedidos repetidos en los pedidos entregados
    # 

# Al final de la simulación
    
    
    #graficar_rutas_y_puntos(camiones, simulacion)
    #graficar_beneficio(simulacion)

def verificar_pedidos_repetidos(pedidos_entregados):
    print(len(pedidos_entregados))

    pedidos_vistos = set()
    pedidos_repetidos = []
    pic = 0
    deli = 0

    for pedido in pedidos_entregados:
        if pedido.indicador == 0:
            deli +=1
        elif pedido.indicador == 1:
            pic +=1
        # Convertir las coordenadas del pedido en una tupla para que sean hashables
        coordenadas = tuple(pedido.coordenadas)
        if coordenadas in pedidos_vistos:
            pedidos_repetidos.append(pedido)
        else:
            pedidos_vistos.add(coordenadas)
    print(pic)
    print(deli)
    return pedidos_repetidos


def graficar_beneficio(simulacion):
    intervalos = [x[0] for x in simulacion.beneficio_por_intervalo]
    porcentajes = [x[1] for x in simulacion.beneficio_por_intervalo]

    if not porcentajes:
        print("No hay datos para graficar.")
        return

    plt.figure(figsize=(10, 5))
    plt.bar(intervalos, porcentajes, width=25, align='center')
    plt.xlabel('Minuto')
    plt.ylabel('Porcentaje de Beneficio Captado')
    plt.title('Porcentaje de Beneficio Captado cada 30 Minutos')
    plt.show()

def evaluar_incorporacion_pickup(camion, parametros, simulacion):
    # Verificar si ya se evaluaron los pick-ups para esta ruta
    if simulacion.minuto_actual < 780:
        return
    if camion.pickups_evaluados:
        return  # No se realiza ninguna acción si ya se evaluaron los pick-ups

    ruta_actual = camion.rutas[-1]
    total_puntos_ruta = len(ruta_actual) - 1  # Excluimos el depósito final
    punto_medio_index = total_puntos_ruta // 2  # Índice del punto medio

    # Obtener solo la lista de tiempos de llegada (primer elemento de la tupla)
    minutos_de_entrega, _ = hora_entrega_pedidos(ruta_actual, [10000, 10000], camion.velocidad, camion.tiempo_inicio_ruta, service_time=3)
    tiempo_actual = simulacion.minuto_actual

    # Verificar si el camión está en el punto medio de la ruta
    if punto_medio_index < len(minutos_de_entrega):
        tiempo_llegada_punto_medio = minutos_de_entrega[punto_medio_index]
        if tiempo_actual >= tiempo_llegada_punto_medio and tiempo_actual < tiempo_llegada_punto_medio + 3:  # En rango de atención del punto medio
            pick_up_nuevos_disponible(camion, parametros, simulacion, punto_medio_index)
            camion.pickups_evaluados = True  # Marcar que los pick-ups ya fueron evaluados
            return
    else:
        # Si por alguna razón el índice está fuera de rango, no hacemos nada
        return



def pick_up_nuevos_disponible(camion, parametros, simulacion, current_index):
    # Verificar si hay pedidos disponibles
    if not simulacion.pedidos_disponibles:
        print(f"No hay solicitudes de pick-up disponibles en el minuto {simulacion.minuto_actual}.")
        return

    nuevos_pickups = []

    # Revisar los pedidos disponibles para identificar los nuevos pick-ups
    for pedido in simulacion.pedidos_disponibles:
        if (
            pedido.indicador == 1 and  # Solo pick-ups
            pedido.disponible == 1 
            #and  # Deben estar disponibles
            #pedido.minuto_llegada >= camion.tiempo_inicio_ruta  # Llegaron después de asignar la ruta
        ):
            nuevos_pickups.append(pedido)

    # Imprimir los nuevos pick-ups disponibles

    if nuevos_pickups:
        
        unvisited = set(range(len(nuevos_pickups))) 
        tiempo_ruta = calcular_tiempo_ruta(camion.rutas[-1], camion.velocidad)
        todos_los_pedidos = simulacion.pedidos_disponibles + simulacion.pedidos_entregados 

        nueva_ruta = cheapest_insertion_adaptacion(simulacion.minuto_actual, parametros, camion, current_index, nuevos_pickups, camion.rutas[-1], todos_los_pedidos, tiempo_limite=180)
        nueva_ruta_aux = nueva_ruta.copy()
        ruta_cam_aux = camion.rutas[-1].copy()

        nueva_ruta_aux.pop(0)
        nueva_ruta_aux.pop(-1)

        ruta_cam_aux.pop(0)
        ruta_cam_aux.pop(-1)

        
        # Verificar si son idénticas
        def listas_identicas(lista1, lista2):
            if len(lista1) != len(lista2): 
                print("Las rutas tienen diferente largo")# Comparar la longitud primero
                return False
            return all(np.array_equal(arr1, arr2) for arr1, arr2 in zip(lista1, lista2))

        if not listas_identicas(nueva_ruta_aux, ruta_cam_aux):
            print("Se cambió la ruta por nueva solicitud de pick up")
            puntos_nuevos = [
                punto for punto in nueva_ruta if not any(np.array_equal(punto, p_antiguo) for p_antiguo in camion.rutas[-1])]
            print(nueva_ruta)
            print(puntos_nuevos)
            camion.rutas[-1] = nueva_ruta
            actualizar_estado_simulacion(simulacion, puntos_nuevos)
            
            # Calcular el nuevo tiempo total de la ruta actualizada
            _, tiempo_total_nueva_ruta = calculate_arrival_times_adapted(
                nueva_ruta,
                camion.velocidad,
                camion.tiempo_inicio_ruta,
                [10000, 10000],
                service_time=3
            )
            
            # Actualizar el tiempo restante del camión
            camion.tiempo_restante = tiempo_total_nueva_ruta - simulacion.minuto_actual
            if camion.tiempo_restante < 0:
                camion.tiempo_restante = 0 
            
            #pasarle solo los pickups nuevos no la ruta completa

    else:
        print(f"No hay nuevas solicitudes de pick-up disponibles en el minuto {simulacion.minuto_actual}.")
    

def hora_entrega_pedidos(ruta, depot, camion_velocidad, minuto_actual, service_time=3):
    arrival_times = []
    current_time = minuto_actual
    current_location = depot

    # Para cada punto en la ruta
    for punto in ruta:
        next_location = punto

        # Calcular el tiempo de viaje al siguiente punto
        distance = manhattan_distance(current_location, next_location)
        travel_time = distance / camion_velocidad

        # Tiempo de llegada al siguiente punto
        arrival_time = current_time + travel_time

        # Actualizar el tiempo actual sumando el tiempo de viaje y el tiempo de atención
        current_time = arrival_time + service_time

        # Almacenar el tiempo de llegada (antes del servicio)
        arrival_times.append(arrival_time)

        # Actualizar la ubicación actual
        current_location = next_location

    # Finalmente, regresar al depósito
    distance = manhattan_distance(current_location, depot)
    travel_time = distance / camion_velocidad
    current_time += travel_time  # Sumar tiempo para regresar al depósito

    return arrival_times, current_time  # Retorna los tiempos de llegada y el tiempo total

# Función que evalúa los criterios de salida de los camiones
def evaluar_salida(camion, simulacion, parametros):
    if camion.tiempo_restante > 0:
        evaluar_incorporacion_pickup(camion, parametros, simulacion)
        return False

    if len(simulacion.pedidos_disponibles) == 0:
        return False

    # Calcula el valor ponderado de los criterios
    valor_ponderado = (
        parametros["peso_min_pedidos"] * (len(simulacion.pedidos_disponibles) / max(1, parametros["min_pedidos_salida"])) +
        parametros["peso_ventana_tiempo"] * (simulacion.minuto_actual % parametros["x_minutos"] == 0)
    )

    # Verifica si el valor ponderado supera el umbral
    return valor_ponderado >= parametros["umbral_salida"]


def registrar_tiempos_delivery(simulacion, camiones):
    # Lista para almacenar los datos de cada delivery (momento de aparición y recogida)
    registros_delivery = []

    # Iterar sobre todos los camiones y sus rutas

    for pedido in simulacion.pedidos_entregados:
        if pedido.indicador == 0:  # Identificar los pedidos de delivery
                registro = {
                    "momento_aparicion": pedido.minuto_llegada,
                    "momento_recogida": pedido.tiempo_entrega
                }
                registros_delivery.append(registro)

    # Convertir a DataFrame
    df_registros = pd.DataFrame(registros_delivery)

    # Guardar en un archivo CSV
    output_path = "registros_delivery.csv"
    df_registros.to_csv(output_path, index=False)
    print(f"Archivo guardado en {output_path}")




def cheapest_insertion_adaptacion(
    minuto_actual, parametros, camion, current_index, pedidos_validos, ruta_actual, todos_los_pedidos, tiempo_limite=180
):
    # Obtener la ubicación y el tiempo actual del camión
    current_location = ruta_actual[current_index]
    
    # Calcular el tiempo de llegada al punto actual
    arrival_times_up_to_current, _ = calculate_arrival_times_adapted(
        ruta_actual[:current_index + 1],
        camion.velocidad,
        camion.tiempo_inicio_ruta,
        [10000, 10000],
        service_time=3
    )
    current_time = arrival_times_up_to_current[-1] + 3  # Añadir tiempo de servicio en el punto actual


    # Lista de pedidos ya en la ruta actual (desde current_index + 1 hasta el final)
    ruta_actual_aux = ruta_actual[current_index + 1:]
    ruta_actual_aux = [cord for cord in ruta_actual_aux if not np.array_equal(cord, [10000, 10000])]

    pedidos_en_ruta = []
    for cord in ruta_actual_aux:
        pedidos_en_punto = [pedido for pedido in todos_los_pedidos if np.array_equal(pedido.coordenadas, cord)]
        if pedidos_en_punto:
            pedidos_en_ruta.append(pedidos_en_punto[0])
        else:
            print(f"No se encontró un pedido para el punto {cord}")

    # Crear una lista combinada de pedidos totales sin duplicados
    pedidos_totales = pedidos_en_ruta.copy()
    for pedido in pedidos_validos:
        if pedido not in pedidos_totales:
            pedidos_totales.append(pedido)

    # Mapear pedidos a sus índices en pedidos_totales
    pedido_a_indice = {pedido: idx for idx, pedido in enumerate(pedidos_totales)}

    # Índices de los pedidos ya en la ruta (inicialmente)
    indices_route = [pedido_a_indice[pedido] for pedido in pedidos_en_ruta]

    # Índices de los nuevos pedidos a considerar para inserción
    unvisited = [pedido_a_indice[pedido] for pedido in pedidos_validos if pedido not in pedidos_en_ruta]

    # Calcular el tiempo total restante sin nuevos pickups
    ruta_remaining_coords = [pedido.coordenadas for pedido in pedidos_en_ruta]
    arrival_times_remaining, tiempo_total_remaining = calculate_arrival_times_adapted(
        ruta_remaining_coords,
        camion.velocidad,
        minuto_actual,
        current_location,
        service_time=3
    )
    tiempo_total = tiempo_total_remaining
    p_insertados = 0
    max_insertados = 1
    while unvisited and p_insertados < max_insertados:
        min_increase = float('inf')
        best_position = None
        best_point = None
        best_total_time = None
        best_arrival_times = None

        # Buscar el mejor punto para insertar
        for point in unvisited:
            if point in indices_route:
                continue
            for i in range(len(indices_route) + 1):
                ruta_temporal = indices_route.copy()
                ruta_temporal.insert(i, point)

                # Construir la ruta completa temporal
                ruta_compl_temp_coords = [current_location] + [pedidos_totales[idx].coordenadas for idx in ruta_temporal]

                # Calcular tiempos de llegada y tiempo total de la ruta
                arrival_times_temp, total_time_temp = calculate_arrival_times_adapted(
                    ruta_compl_temp_coords,
                    camion.velocidad,
                    minuto_actual,
                    current_location,
                    service_time=3
                )

                # Verificar si cumple con el horizonte de tiempo
                if total_time_temp > 1019:
                    continue

                # Verificar que todos los puntos pueden atenderse antes de su vencimiento
                all_points_valid = True
                for idx_ruta, arrival_time in zip(ruta_temporal, arrival_times_temp):
                    pedido_ruta = pedidos_totales[idx_ruta]
                    expiration_time_ruta = pedido_ruta.minuto_llegada + tiempo_limite
                    if arrival_time > expiration_time_ruta:
                        all_points_valid = False
                        break

                if not all_points_valid:
                    continue

                # Calcular incremento en tiempo
                increase = total_time_temp - tiempo_total

                # Rechazo para "Pick-ups"
                if (pedidos_totales[point].indicador == 1 and
                        increase > parametros["max_aumento_distancia_en_ruta"] * (minuto_actual / parametros["tiempo_necesario_pick_up_en_ruta"]) and
                        tiempo_total < parametros["tiempo_necesario_pick_up_en_ruta"]):
                    continue

                # Elegir este punto si el incremento es el menor
                if increase < min_increase:
                    min_increase = increase
                    best_position = i
                    best_point = point
                    best_total_time = total_time_temp
                    best_arrival_times = arrival_times_temp

        # Si se encuentra un punto para insertar
        if best_point is not None:
            indices_route.insert(best_position, best_point)
            unvisited.remove(best_point)
            tiempo_total = best_total_time
            arrival_times = best_arrival_times
            p_insertados +=1
            print('SE ENCONTRO PUNTO')
        else:
            print('NO HAY PUNTO')
            break

    # Construir la ruta final
    ruta_final_coords = ruta_actual[:current_index + 1] + [pedidos_totales[idx].coordenadas for idx in indices_route] + [[10000, 10000]]
    return ruta_final_coords

def calculate_arrival_times_adapted(ruta_coords, camion_velocidad, current_time, current_location, service_time=3):
    arrival_times = []

    # Para cada punto en la ruta
    for coord in ruta_coords:
        next_location = coord

        # Calcular el tiempo de viaje al siguiente punto
        distance = manhattan_distance(current_location, next_location)
        travel_time = distance / camion_velocidad

        # Tiempo de llegada al siguiente punto
        arrival_time = current_time + travel_time

        # Almacenar el tiempo de llegada
        arrival_times.append(arrival_time)

        # Actualizar el tiempo actual sumando el tiempo de atención
        current_time = arrival_time + service_time

        # Actualizar la ubicación actual
        current_location = next_location

    # Finalmente, regresar al depósito
    distance = manhattan_distance(current_location, [10000, 10000])
    travel_time = distance / camion_velocidad
    current_time += travel_time  # Sumar tiempo para regresar al depósito

    return arrival_times, current_time # Retorna los tiempos de llegada y el tiempo total


#parametros con 1000 it optuna.
#instancia 1

# {'min_pedidos_salida': 12, 'porcentaje_reduccion_distancia': 61, 'max_puntos_eliminados': 10, 'x_minutos': 42, 'limite_area1': 109, 'limite_area2': 254, 'peso_min_pedidos': 1.744717231972422, 'peso_ventana_tiempo': 1.1783687671367267, 'umbral_salida': 1.1204819899567817, 'tiempo_minimo_pickup': 25, 'max_aumento_distancia': 7, 'tiempo_necesario_pick_up': 65, 'tiempo_restante_max': 60, 'max_aumento_distancia_delivery': 1197}

# {'min_pedidos_salida': 20, 'porcentaje_reduccion_distancia': 33, 'max_puntos_eliminados': 9, 'x_minutos': 18, 'limite_area1': 111, 'limite_area2': 188, 'peso_min_pedidos': 1.1848891982324603, 'peso_ventana_tiempo': 1.5624060231825407, 'umbral_salida': 1.6175862128535314, 'tiempo_minimo_pickup': 20, 'max_aumento_distancia': 16, 'tiempo_necesario_pick_up': 1496, 'tiempo_restante_max': 17, 'max_aumento_distancia_delivery': 595}

# {'min_pedidos_salida': 15, 'porcentaje_reduccion_distancia': 45, 'max_puntos_eliminados': 13, 'x_minutos': 9, 'limite_area1': 132, 'limite_area2': 190, 'peso_min_pedidos': 1.5774308454975026, 'peso_ventana_tiempo': 1.1731581230854333, 'umbral_salida': 1.3076635672736978, 'tiempo_minimo_pickup': 18, 'max_aumento_distancia': 11, 'tiempo_necesario_pick_up': 1371, 'tiempo_restante_max': 103, 'max_aumento_distancia_delivery': 893}

#I2

# {'min_pedidos_salida': 5, 'porcentaje_reduccion_distancia': 55, 'max_puntos_eliminados': 19, 'x_minutos': 60, 'limite_area1': 139, 'limite_area2': 270, 'peso_min_pedidos': 1.270769165494037, 'peso_ventana_tiempo': 0.5334298758833237, 'umbral_salida': 1.142787259922978, 'tiempo_minimo_pickup': 33, 'max_aumento_distancia': 20, 'tiempo_necesario_pick_up': 647, 'tiempo_restante_max': 97, 'max_aumento_distancia_delivery': 232}

# {'min_pedidos_salida': 5, 'porcentaje_reduccion_distancia': 43, 'max_puntos_eliminados': 11, 'x_minutos': 3, 'limite_area1': 126, 'limite_area2': 200, 'peso_min_pedidos': 1.9875097075448465, 'peso_ventana_tiempo': 1.9411077324851984, 'umbral_salida': 1.2940403662686877, 'tiempo_minimo_pickup': 36, 'max_aumento_distancia': 7, 'tiempo_necesario_pick_up': 1104, 'tiempo_restante_max': 132, 'max_aumento_distancia_delivery': 38}

# {'min_pedidos_salida': 20, 'porcentaje_reduccion_distancia': 68, 'max_puntos_eliminados': 18, 'x_minutos': 14, 'limite_area1': 91, 'limite_area2': 265, 'peso_min_pedidos': 1.1700431872055927, 'peso_ventana_tiempo': 1.9398927740769498, 'umbral_salida': 1.0454057612407521, 'tiempo_minimo_pickup': 23, 'max_aumento_distancia': 10, 'tiempo_necesario_pick_up': 814, 'tiempo_restante_max': 111, 'max_aumento_distancia_delivery': 1224}

#instancia 3
# {'min_pedidos_salida': 1, 'porcentaje_reduccion_distancia': 47, 'max_puntos_eliminados': 16, 'x_minutos': 18, 'limite_area1': 147, 'limite_area2': 215, 'peso_min_pedidos': 1.6525938339343251, 'peso_ventana_tiempo': 1.8947957184968578, 'umbral_salida': 1.126101447963525, 'tiempo_minimo_pickup': 31, 'max_aumento_distancia': 16, 'tiempo_necesario_pick_up': 661, 'tiempo_restante_max': 106, 'max_aumento_distancia_delivery': 1048}

# {'min_pedidos_salida': 3, 'porcentaje_reduccion_distancia': 54, 'max_puntos_eliminados': 15, 'x_minutos': 9, 'limite_area1': 140, 'limite_area2': 243, 'peso_min_pedidos': 1.8017927848294588, 'peso_ventana_tiempo': 1.325020645146538, 'umbral_salida': 1.488642659103274, 'tiempo_minimo_pickup': 37, 'max_aumento_distancia': 14, 'tiempo_necesario_pick_up': 975, 'tiempo_restante_max': 181, 'max_aumento_distancia_delivery': 1351}

# {'min_pedidos_salida': 12, 'porcentaje_reduccion_distancia': 42, 'max_puntos_eliminados': 17, 'x_minutos': 25, 'limite_area1': 110, 'limite_area2': 231, 'peso_min_pedidos': 1.0883231580184491, 'peso_ventana_tiempo': 1.0133168647668476, 'umbral_salida': 1.9840669226875491, 'tiempo_minimo_pickup': 34, 'max_aumento_distancia': 12, 'tiempo_necesario_pick_up': 1438, 'tiempo_restante_max': 68, 'max_aumento_distancia_delivery': 1355}

#I4
# {'min_pedidos_salida': 16, 'porcentaje_reduccion_distancia': 54, 'max_puntos_eliminados': 14, 'x_minutos': 47, 'limite_area1': 92, 'limite_area2': 259, 'peso_min_pedidos': 0.5013335069404848, 'peso_ventana_tiempo': 1.9178586787518015, 'umbral_salida': 1.848042237458438, 'tiempo_minimo_pickup': 34, 'max_aumento_distancia': 14, 'tiempo_necesario_pick_up': 1433, 'tiempo_restante_max': 8, 'max_aumento_distancia_delivery': 1223}

# {'min_pedidos_salida': 18, 'porcentaje_reduccion_distancia': 43, 'max_puntos_eliminados': 16, 'x_minutos': 3, 'limite_area1': 123, 'limite_area2': 202, 'peso_min_pedidos': 1.1209231634506647, 'peso_ventana_tiempo': 1.6934702849358318, 'umbral_salida': 1.7599227622579043, 'tiempo_minimo_pickup': 31, 'max_aumento_distancia': 20, 'tiempo_necesario_pick_up': 1326, 'tiempo_restante_max': 116, 'max_aumento_distancia_delivery': 443}

# {'min_pedidos_salida': 16, 'porcentaje_reduccion_distancia': 63, 'max_puntos_eliminados': 10, 'x_minutos': 7, 'limite_area1': 118, 'limite_area2': 183, 'peso_min_pedidos': 1.468924730202163, 'peso_ventana_tiempo': 1.8249477249553931, 'umbral_salida': 1.5368405114652302, 'tiempo_minimo_pickup': 16, 'max_aumento_distancia': 14, 'tiempo_necesario_pick_up': 1046, 'tiempo_restante_max': 35, 'max_aumento_distancia_delivery': 543}



# Parámetros de la simulación (ajustables por Optuna)
parametros_ventana_1 = {'min_pedidos_salida': 8, 'porcentaje_reduccion_distancia': 69, 'max_puntos_eliminados': 18, 'x_minutos': 36, 'limite_area1': 130, 'limite_area2': 263, 'peso_min_pedidos': 0.8539602391541146, 'peso_ventana_tiempo': 1.4716156151156219, 'umbral_salida': 1.2899961479169701, 'tiempo_minimo_pickup': 22, 'max_aumento_distancia': 13, 'tiempo_necesario_pick_up': 1338, 'tiempo_restante_max': 190, 'max_aumento_distancia_delivery': 1016, 'tiempo_necesario_pick_up_en_ruta': 10, 'max_aumento_distancia_en_ruta': 13000}

parametros_ventana_2 = {'min_pedidos_salida': 5, 'porcentaje_reduccion_distancia': 34, 'max_puntos_eliminados': 9, 'x_minutos': 16, 'limite_area1': 148, 'limite_area2': 184, 'peso_min_pedidos': 1.6641134475979422, 'peso_ventana_tiempo': 1.588743965974094, 'umbral_salida': 1.4367916479682685, 'tiempo_minimo_pickup': 43, 'max_aumento_distancia': 8, 'tiempo_necesario_pick_up': 836, 'tiempo_restante_max': 11, 'max_aumento_distancia_delivery': 28, 'tiempo_necesario_pick_up_en_ruta': 10, 'max_aumento_distancia_en_ruta': 13000}

parametros_ventana_3 = {'min_pedidos_salida': 1, 'porcentaje_reduccion_distancia': 33, 'max_puntos_eliminados': 18, 'x_minutos': 15, 'limite_area1': 122, 'limite_area2': 225, 'peso_min_pedidos': 0.5389202543851898, 'peso_ventana_tiempo': 1.369371705453108, 'umbral_salida': 1.4795958635544573, 'tiempo_minimo_pickup': 43, 'max_aumento_distancia': 19, 'tiempo_necesario_pick_up': 1211, 'tiempo_restante_max': 96, 'max_aumento_distancia_delivery': 556, 'tiempo_necesario_pick_up_en_ruta': 10, 'max_aumento_distancia_en_ruta': 13000}



# Cargar los datos de la simulación desde archivos pickle
with open("Instancia Tipo IV/scen_points_sample.pkl", 'rb') as f:
    points = pickle.load(f)[3]  # Seleccionar la primera simulación para este ejemplo
with open('Instancia Tipo IV/scen_arrivals_sample.pkl', 'rb') as f:
    llegadas = pickle.load(f)[3]
with open('Instancia Tipo IV/scen_indicador_sample.pkl', 'rb') as f:
    indicadores = pickle.load(f)[3]

arribos_por_minuto = procesar_tiempos([llegadas], division_minutos=60)[0]
simulacion = EstadoSimulacion(minuto_inicial=520, puntos=points, indicadores=indicadores, arribos_por_minuto=arribos_por_minuto)

# Inicializar los camiones
camiones = [
    Camion(id=1, tiempo_inicial=0),
    Camion(id=2, tiempo_inicial=0),
    Camion(id=3, tiempo_inicial=0)
]

simular_minuto_a_minuto(simulacion, camiones, parametros_ventana_1, parametros_ventana_2, parametros_ventana_3)

registrar_tiempos_delivery(simulacion, camiones)

#pedidos_repetidos = verificar_pedidos_repetidos(simulacion.pedidos_entregados)
    
# if pedidos_repetidos:
#         print("Se encontraron pedidos repetidos en los entregados:")
#         for pedido in pedidos_repetidos:
#             print(f"Pedido repetido en coordenadas: {pedido.coordenadas}")
# else:
#         print("No se encontraron pedidos repetidos en los entregados.")

# Llamar a la función para crear el GIF
crear_gif_con_movimiento_camiones(simulacion)
