# Parametros calibrados:
# * Instancia 1:
#     * {'min_pedidos_salida': 17, 'porcentaje_reduccion_distancia': 31, 'max_puntos_eliminados': 14, 'x_minutos': 20, 'limite_area1': 128, 'limite_area2': 210, 'peso_min_pedidos': 1.4258208140237363, 'peso_ventana_tiempo': 1.7845358791509105, 'umbral_salida': 1.9097996396208297, 'tiempo_minimo_pickup': 39, 'max_aumento_distancia': 11, 'tiempo_necesario_pick_up': 1378, 'tiempo_restante_max': 111, 'max_aumento_distancia_delivery': 844}
#     * 
#     * {'min_pedidos_salida': 13, 'porcentaje_reduccion_distancia': 37, 'max_puntos_eliminados': 8, 'x_minutos': 59, 'limite_area1': 134, 'limite_area2': 186, 'peso_min_pedidos': 1.4345567915049973, 'peso_ventana_tiempo': 1.3588844137499472, 'umbral_salida': 1.3851690157693943, 'tiempo_minimo_pickup': 38, 'max_aumento_distancia': 20, 'tiempo_necesario_pick_up': 968, 'tiempo_restante_max': 9, 'max_aumento_distancia_delivery': 29}
#     * 
#     * {'min_pedidos_salida': 17, 'porcentaje_reduccion_distancia': 62, 'max_puntos_eliminados': 17, 'x_minutos': 56, 'limite_area1': 93, 'limite_area2': 270, 'peso_min_pedidos': 1.3683745561452805, 'peso_ventana_tiempo': 1.5087497070531928, 'umbral_salida': 1.609613386809045, 'tiempo_minimo_pickup': 26, 'max_aumento_distancia': 9, 'tiempo_necesario_pick_up': 1054, 'tiempo_restante_max': 137, 'max_aumento_distancia_delivery': 11}
# * Instancia 2:
#     * {'min_pedidos_salida': 14, 'porcentaje_reduccion_distancia': 36, 'max_puntos_eliminados': 7, 'x_minutos': 3, 'limite_area1': 134, 'limite_area2': 210, 'peso_min_pedidos': 1.9687142346197708, 'peso_ventana_tiempo': 1.1025506899704678, 'umbral_salida': 1.7115549689422893, 'tiempo_minimo_pickup': 18, 'max_aumento_distancia': 7, 'tiempo_necesario_pick_up': 1413, 'tiempo_restante_max': 130, 'max_aumento_distancia_delivery': 280}
#     * 
#     * {'min_pedidos_salida': 18, 'porcentaje_reduccion_distancia': 30, 'max_puntos_eliminados': 16, 'x_minutos': 2, 'limite_area1': 92, 'limite_area2': 213, 'peso_min_pedidos': 1.389935989337192, 'peso_ventana_tiempo': 0.8677152709217305, 'umbral_salida': 1.392232984569243, 'tiempo_minimo_pickup': 28, 'max_aumento_distancia': 9, 'tiempo_necesario_pick_up': 886, 'tiempo_restante_max': 101, 'max_aumento_distancia_delivery': 29}
#     * 
#     * {'min_pedidos_salida': 17, 'porcentaje_reduccion_distancia': 63, 'max_puntos_eliminados': 14, 'x_minutos': 27, 'limite_area1': 109, 'limite_area2': 199, 'peso_min_pedidos': 1.129656004873347, 'peso_ventana_tiempo': 0.6032264027418948, 'umbral_salida': 1.1825581718546028, 'tiempo_minimo_pickup': 17, 'max_aumento_distancia': 5, 'tiempo_necesario_pick_up': 1143, 'tiempo_restante_max': 100, 'max_aumento_distancia_delivery': 41}
# * Instancia 3:
#     * {'min_pedidos_salida': 1, 'porcentaje_reduccion_distancia': 54, 'max_puntos_eliminados': 6, 'x_minutos': 50, 'limite_area1': 119, 'limite_area2': 267, 'peso_min_pedidos': 0.5971182427582737, 'peso_ventana_tiempo': 0.713478246757084, 'umbral_salida': 1.011875143339422, 'tiempo_minimo_pickup': 31, 'max_aumento_distancia': 13, 'tiempo_necesario_pick_up': 824, 'tiempo_restante_max': 118, 'max_aumento_distancia_delivery': 491}
#     * 
#     * {'min_pedidos_salida': 5, 'porcentaje_reduccion_distancia': 63, 'max_puntos_eliminados': 9, 'x_minutos': 40, 'limite_area1': 144, 'limite_area2': 239, 'peso_min_pedidos': 1.2709372730059911, 'peso_ventana_tiempo': 1.5742119038813274, 'umbral_salida': 1.587618895342463, 'tiempo_minimo_pickup': 44, 'max_aumento_distancia': 14, 'tiempo_necesario_pick_up': 1272, 'tiempo_restante_max': 122, 'max_aumento_distancia_delivery': 19}
#     * 
#     * {'min_pedidos_salida': 19, 'porcentaje_reduccion_distancia': 67, 'max_puntos_eliminados': 13, 'x_minutos': 1, 'limite_area1': 140, 'limite_area2': 180, 'peso_min_pedidos': 0.7993143719423276, 'peso_ventana_tiempo': 0.8241533963555013, 'umbral_salida': 1.231678361485861, 'tiempo_minimo_pickup': 27, 'max_aumento_distancia': 8, 'tiempo_necesario_pick_up': 1405, 'tiempo_restante_max': 174, 'max_aumento_distancia_delivery': 82}
# * Instancia 4:
#     * {'min_pedidos_salida': 2, 'porcentaje_reduccion_distancia': 46, 'max_puntos_eliminados': 13, 'x_minutos': 8, 'limite_area1': 143, 'limite_area2': 232, 'peso_min_pedidos': 1.3650083117702956, 'peso_ventana_tiempo': 1.8548290102815066, 'umbral_salida': 1.5601612050582978, 'tiempo_minimo_pickup': 17, 'max_aumento_distancia': 12, 'tiempo_necesario_pick_up': 1294, 'tiempo_restante_max': 195, 'max_aumento_distancia_delivery': 1227}
#     * 
#     * {'min_pedidos_salida': 2, 'porcentaje_reduccion_distancia': 49, 'max_puntos_eliminados': 12, 'x_minutos': 37, 'limite_area1': 109, 'limite_area2': 235, 'peso_min_pedidos': 1.3462605634101168, 'peso_ventana_tiempo': 1.523125976294386, 'umbral_salida': 1.4604432560468708, 'tiempo_minimo_pickup': 37, 'max_aumento_distancia': 11, 'tiempo_necesario_pick_up': 1445, 'tiempo_restante_max': 54, 'max_aumento_distancia_delivery': 1436}
#     * 
#     * {'min_pedidos_salida': 15, 'porcentaje_reduccion_distancia': 68, 'max_puntos_eliminados': 11, 'x_minutos': 58, 'limite_area1': 141, 'limite_area2': 239, 'peso_min_pedidos': 1.9138181730131887, 'peso_ventana_tiempo': 1.8613353548514777, 'umbral_salida': 1.3676121600899114, 'tiempo_minimo_pickup': 33, 'max_aumento_distancia': 9, 'tiempo_necesario_pick_up': 1442, 'tiempo_restante_max': 166, 'max_aumento_distancia_delivery': 916}



import numpy as np
from ruteo import *
import pickle
import matplotlib.pyplot as plt
from funciones_caso_base import *


#Pasos a implementar forma inteligente y con un parametro modificable de priorizar los deliveries con los pick ups
#Forma inteligente de incertar un pick up a una ruta en movimiento
#Forma de descartar los pedidos de una ruta en caso de mejora
#Mejorar la iniciacion de la funcion para que esta se puedan modificar de forma intelegente los parametros

def separar_y_seleccionar_area(pedidos_disponibles):
    # Separar los pedidos según su área
    pedidos_area1 = [pedido for pedido in pedidos_disponibles if pedido.area == 1]
    pedidos_area2 = [pedido for pedido in pedidos_disponibles if pedido.area == 2]
    pedidos_area3 = [pedido for pedido in pedidos_disponibles if pedido.area == 3]

    # Calcular cuál área tiene más pedidos
    max_area = max(len(pedidos_area1), len(pedidos_area2), len(pedidos_area3))

    if max_area == len(pedidos_area1):
        return pedidos_area1
    elif max_area == len(pedidos_area2):
        return pedidos_area2
    else:
        return pedidos_area3


def flujo_ruteo(camion, simulacion, parametros):
    # 1. Obtener los pedidos disponibles
    pedidos_disponibles = simulacion.pedidos_disponibles

    # 3. Separar los pedidos según su área y seleccionar el área con más pedidos
    pedidos_a_rutear = separar_y_seleccionar_area(pedidos_disponibles)

    depot=[10000, 10000]
    # 4. Generar la ruta según los pedidos en el área con más pedidos
    ruta = generar_ruta(points, depot, camion, simulacion.minuto_actual, pedidos_a_rutear, parametros, tiempo_limite=180)


    # 7. Actualizar los pedidos entregados
    actualizar_estado_simulacion(simulacion, ruta)

    # 8. Actualizar el camión con la nueva ruta
    tiempo_ruta = calcular_tiempo_ruta(ruta, camion.velocidad)
    camion.asignar_ruta(ruta, tiempo_ruta, simulacion.minuto_actual)
    # 9. Devolver la ruta y el tiempo de la ruta
    return ruta, tiempo_ruta


def asignar_area(punto, parametros):
    x, y = punto
    cx, cy = 10000, 10000  # Centro del mapa
    vector = np.array([x - cx, y - cy])
    angle = np.degrees(np.arctan2(vector[1], vector[0]))

    if angle < 0:
        angle += 360

    # Usar los dos parámetros de ángulo para definir los límites de las tres áreas
    limite_area1 = parametros["limite_area1"]
    limite_area2 = parametros["limite_area2"]

    if 0 <= angle < limite_area1:
        return 1  # Área 1
    elif limite_area1 <= angle < limite_area2:
        return 2  # Área 2
    else:
        return 3  # Área 3

# Función para actualizar el estado de la simulación, marcando los puntos de la ruta como visitados
def actualizar_estado_simulacion(simulacion, ruta):
    # Lista para almacenar los pedidos que se entregarán
    pedidos_a_entregar = []
    puntos_sin_pedidos = []

    # Para cada punto en la ruta, buscar el pedido correspondiente en pedidos disponibles
    for punto in ruta:
        pedidos_en_punto = [pedido for pedido in simulacion.pedidos_disponibles if np.array_equal(pedido.coordenadas, punto)]
        
        pedidos_a_entregar.extend(pedidos_en_punto)

    # Actualizar el estado de los pedidos y las listas de la simulación
    for pedido in pedidos_a_entregar:
        # Cambiar el estado del pedido a entregado
        pedido.entregar(simulacion.minuto_actual)
        # Mover el pedido a la lista de pedidos entregados
        simulacion.pedidos_entregados.append(pedido)

    # Remover los pedidos entregados de la lista de pedidos disponibles
    simulacion.pedidos_disponibles = [pedido for pedido in simulacion.pedidos_disponibles if pedido not in pedidos_a_entregar]

def simular_minuto_a_minuto(simulacion, camiones, parametros_ventana_1, parametros_ventana_2, parametros_ventana_3):
    # Inicia la simulación desde las 8:30 AM (minuto 630) hasta las 7:00 PM (1110 minutos)
    for minuto in range(520, 1020):
        simulacion.minuto_actual = minuto
        print(f"Minuto {minuto}: simulando...")

        if minuto <= 650:
            parametros = parametros_ventana_1
        elif 651 <= minuto <= 780:
            parametros = parametros_ventana_2
        else:
            parametros = parametros_ventana_3
        # Actualizar los pedidos disponibles minuto a minuto
        simulacion.revisar_pedidos_disponibles()


        # Actualizar tiempos de los camiones
        for camion in camiones:
            camion.actualizar_tiempo()
            
        # Evaluar si los camiones deben salir a rutear
        for camion in camiones:
            if evaluar_salida(camion, simulacion, parametros):
                # Gestionar el camión cuando sale a realizar una ruta
                flujo_ruteo(camion, simulacion, parametros)
        
        # Cada 30 minutos, calcular el porcentaje de beneficio captado
        if minuto % 30 == 0:
            beneficio_acumulado = simulacion.calcular_beneficio_acumulado()
            porcentaje_beneficio = simulacion.calcular_porcentaje_beneficio(beneficio_acumulado)
            simulacion.beneficio_por_intervalo.append((minuto, porcentaje_beneficio))

        # Avanza el minuto en la simulación
        simulacion.avanzar_minuto()
        simulacion.registrar_estado(camiones)
    
    print(len(simulacion.pedidos_entregados))
    print("Simulación finalizada.")
    

    for camion in camiones:
        tiempo_en_ruta = 0

        for ruta in camion.rutas:
            tiempo_en_ruta += calcular_tiempo_ruta(ruta, camion.velocidad)

        print(f"Camión {camion.id}:")
        print(f"Veces que realizó rutas: {len(camion.rutas)}")
        print(f"Tiempo total manejado: {tiempo_en_ruta / 60:.2f} horas")

    beneficio_total = calcular_beneficio(simulacion)
    distancia_total = calcular_distancia_total(camiones)

    print(f"Beneficio total: {beneficio_total}")
    print(f"Distancia total recorrida: {distancia_total} M")

    tiempos_respuesta = [pedido.tiempo_entrega for pedido in simulacion.pedidos_entregados if pedido.tiempo_entrega is not None]
    tiempo_respuesta_promedio = sum(tiempos_respuesta) / len(tiempos_respuesta)
    print(f"Tiempo de respuesta promedio: {tiempo_respuesta_promedio:.2f} minutos")


    # Contar la cantidad de pick-ups y deliveries realizados
    cantidad_pickups = sum(1 for pedido in simulacion.pedidos_entregados if pedido.indicador == 1)
    cantidad_deliveries = sum(1 for pedido in simulacion.pedidos_entregados if pedido.indicador == 0)

    # Imprimir el conteo de pick-ups y deliveries
    print(f"Cantidad de pick-ups realizados: {cantidad_pickups}")
    print(f"Cantidad de deliveries realizados: {cantidad_deliveries}")

    print()
    # Análisis dentro de rutas individuales y entre rutas del mismo camión
    for camion in camiones:
        print(f"Analizando repeticiones para el Camión {camion.id}:")

        # Verificar repeticiones dentro de cada ruta
        for i, ruta in enumerate(camion.rutas):
            # Excluir el depósito del análisis
            puntos_unicos = set(tuple(punto) for punto in ruta if not np.array_equal(punto, [10000, 10000]))
            ruta_filtrada = [punto for punto in ruta if not np.array_equal(punto, [10000, 10000])]
            if len(puntos_unicos) < len(ruta_filtrada):
                print(f"  Ruta {i + 1} tiene puntos repetidos dentro de sí misma (excluyendo el depósito).")
            else:
                print(f"  Ruta {i + 1} no tiene puntos repetidos dentro de sí misma (excluyendo el depósito).")

        # Verificar repeticiones entre rutas
        puntos_todas_rutas = set()
        puntos_repetidos = set()
        for ruta in camion.rutas:
            for punto in ruta:
                if np.array_equal(punto, [10000, 10000]):
                    continue  # Ignorar el depósito
                punto_tuple = tuple(punto)
                if punto_tuple in puntos_todas_rutas:
                    puntos_repetidos.add(punto_tuple)
                else:
                    puntos_todas_rutas.add(punto_tuple)

        if puntos_repetidos:
            print(f"  Hay puntos repetidos entre rutas (excluyendo el depósito): {puntos_repetidos}")
        else:
            print("  No hay puntos repetidos entre rutas (excluyendo el depósito).")

    # Comparación entre camiones
    print("\nComparación de puntos entre camiones (excluyendo el depósito):")
    puntos_por_camion = {}  # Diccionario para almacenar los puntos visitados por cada camión

    # Recopilar puntos visitados por cada camión, excluyendo el depósito
    for camion in camiones:
        puntos_visitados = set(tuple(punto) for ruta in camion.rutas for punto in ruta if not np.array_equal(punto, [10000, 10000]))
        puntos_por_camion[camion.id] = puntos_visitados

    # Comparar puntos entre camiones
    for id1, puntos_camion1 in puntos_por_camion.items():
        for id2, puntos_camion2 in puntos_por_camion.items():
            if id1 < id2:  # Evitar comparaciones duplicadas
                puntos_repetidos = puntos_camion1 & puntos_camion2  # Intersección de puntos
                if puntos_repetidos:
                    print(f"  Camión {id1} y Camión {id2} tienen puntos repetidos: {puntos_repetidos}")
                else:
                    print(f"  Camión {id1} y Camión {id2} no tienen puntos repetidos.")
    
    #graficar_rutas_y_puntos(camiones, simulacion)
    #graficar_beneficio(simulacion)

def graficar_beneficio(simulacion):
    intervalos = [x[0] for x in simulacion.beneficio_por_intervalo]
    porcentajes = [x[1] for x in simulacion.beneficio_por_intervalo]

    if not porcentajes:
        print("No hay datos para graficar.")
        return

    plt.figure(figsize=(10, 5))
    plt.bar(intervalos, porcentajes, width=25, align='center')
    plt.xlabel('Minuto')
    plt.ylabel('Porcentaje de Beneficio Captado')
    plt.title('Porcentaje de Beneficio Captado cada 30 Minutos')
    plt.show()

def evaluar_incorporacion_pickup(camion, parametros, simulacion):
    ruta_actual = camion.rutas[-1]
    
    # Obtener solo la lista de tiempos de llegada (primer elemento de la tupla)
    minutos_de_entrega, _ = hora_entrega_pedidos(ruta_actual, [10000, 10000], camion.velocidad, camion.tiempo_inicio_ruta, service_time=3)
    tiempo_actual = simulacion.minuto_actual
    # Verificar si el camión está en alguna casa
    for i, tiempo_llegada in enumerate(minutos_de_entrega):
        if tiempo_actual >= tiempo_llegada and tiempo_actual < tiempo_llegada + 3:  # En rango de atención
                
                pick_up_nuevos_disponible(camion, parametros, simulacion, i)
                return 

    # Si no está en una casa, está avanzando
    print("El camión está en camino hacia el próximo punto.")

def pick_up_nuevos_disponible(camion, parametros, simulacion, current_index):
    # Verificar si hay pedidos disponibles
    if not simulacion.pedidos_disponibles:
        print(f"No hay solicitudes de pick-up disponibles en el minuto {simulacion.minuto_actual}.")
        return

    nuevos_pickups = []

    # Revisar los pedidos disponibles para identificar los nuevos pick-ups
    for pedido in simulacion.pedidos_disponibles:
        if (
            pedido.indicador == 1 and  # Solo pick-ups
            pedido.disponible == 1 and  # Deben estar disponibles
            pedido.minuto_llegada >= camion.tiempo_inicio_ruta  # Llegaron después de asignar la ruta
        ):
            nuevos_pickups.append(pedido)

    # Imprimir los nuevos pick-ups disponibles

    if nuevos_pickups:
        unvisited = set(range(len(nuevos_pickups))) 
        tiempo_ruta = calcular_tiempo_ruta(camion.rutas[-1], camion.velocidad)
        nueva_ruta = cheapest_insertion_adaptacion(tiempo_ruta, parametros, camion, current_index, nuevos_pickups, camion.rutas[-1])

        nueva_ruta_aux = nueva_ruta.copy()
        ruta_cam_aux = camion.rutas[-1].copy()

        nueva_ruta_aux.pop(0)
        nueva_ruta_aux.pop(-1)

        ruta_cam_aux.pop(0)
        ruta_cam_aux.pop(-1)

        # print(ruta_cam_aux)
        # print()
        # print(nueva_ruta_aux)
        # print()


        # Verificar si son idénticas
        def listas_identicas(lista1, lista2):
            if len(lista1) != len(lista2):  # Comparar la longitud primero
                return False
            return all(np.array_equal(arr1, arr2) for arr1, arr2 in zip(lista1, lista2))

        if  not listas_identicas(nueva_ruta_aux, ruta_cam_aux):
            print("Se cambio la ruta por nueva solicitud de pick up")
            print(nueva_ruta)
            print()
            print(camion.rutas[-1])
            puntos_nuevos = [
                            punto for punto in nueva_ruta if not any(np.array_equal(punto, p_antiguo) for p_antiguo in camion.rutas[-1])]
    
            camion.rutas[-1] = nueva_ruta
            actualizar_estado_simulacion(simulacion, puntos_nuevos)
            #pasarle solo los pickups nuevos no la ruta completa

    else:
        print(f"No hay nuevas solicitudes de pick-up disponibles en el minuto {simulacion.minuto_actual}.")
    

def hora_entrega_pedidos(ruta, depot, camion_velocidad, minuto_actual, service_time=3):
    arrival_times = []
    current_time = minuto_actual
    current_location = depot

    # Para cada punto en la ruta
    for punto in ruta:
        next_location = punto

        # Calcular el tiempo de viaje al siguiente punto
        distance = manhattan_distance(current_location, next_location)
        travel_time = distance / camion_velocidad

        # Tiempo de llegada al siguiente punto
        arrival_time = current_time + travel_time

        # Actualizar el tiempo actual sumando el tiempo de viaje y el tiempo de atención
        current_time = arrival_time + service_time

        # Almacenar el tiempo de llegada (antes del servicio)
        arrival_times.append(arrival_time)

        # Actualizar la ubicación actual
        current_location = next_location

    # Finalmente, regresar al depósito
    distance = manhattan_distance(current_location, depot)
    travel_time = distance / camion_velocidad
    current_time += travel_time  # Sumar tiempo para regresar al depósito

    return arrival_times, current_time  # Retorna los tiempos de llegada y el tiempo total

# Función que evalúa los criterios de salida de los camiones
def evaluar_salida(camion, simulacion, parametros):
    if camion.tiempo_restante > 0:
        #evaluar_incorporacion_pickup(camion, parametros, simulacion)
        return False

    if len(simulacion.pedidos_disponibles) == 0:
        return False

    # Calcula el valor ponderado de los criterios
    valor_ponderado = (
        parametros["peso_min_pedidos"] * (len(simulacion.pedidos_disponibles) / max(1, parametros["min_pedidos_salida"])) +
        parametros["peso_ventana_tiempo"] * (simulacion.minuto_actual % parametros["x_minutos"] == 0)
    )

    # Verifica si el valor ponderado supera el umbral
    return valor_ponderado >= parametros["umbral_salida"]


def registrar_tiempos_delivery(simulacion, camiones):
    # Lista para almacenar los datos de cada delivery (momento de aparición y recogida)
    registros_delivery = []

    # Iterar sobre todos los camiones y sus rutas
    for camion in camiones:
        for pedido in simulacion.pedidos_entregados:
            if pedido.indicador == 0:  # Identificar los pedidos de delivery
                registro = {
                    "momento_aparicion": pedido.minuto_llegada,
                    "momento_recogida": pedido.tiempo_entrega
                }
                registros_delivery.append(registro)

    # Convertir a DataFrame
    df_registros = pd.DataFrame(registros_delivery)

    # Guardar en un archivo CSV
    output_path = "registros_delivery.csv"
    df_registros.to_csv(output_path, index=False)
    print(f"Archivo guardado en {output_path}")




def cheapest_insertion_adaptacion(
    tiempo_total, parametros, camion, current_index, pedidos_validos, ruta_actual, tiempo_limite=180
):
    pedidos_en_ruta = []
    # Limitar la ruta actual a partir del índice actual y excluir el depósito
    ruta_actual = ruta_actual[current_index:]
    ruta_actual = [cord for cord in ruta_actual if not np.array_equal(cord, [10000, 10000])]

    # Recopilar pedidos ya entregados presentes en la ruta actual
    for cord in ruta_actual:
        pedidos_en_punto = [pedido for pedido in simulacion.pedidos_entregados if np.array_equal(pedido.coordenadas, cord)]
        if pedidos_en_punto:
            pedidos_en_ruta.append(pedidos_en_punto[0])
        else:
            print(f"No se encontró un pedido para el punto {cord}")

    # Agregar los nuevos pedidos válidos a los pedidos en la ruta
    pedidos_en_ruta.extend(pedidos_validos)
    pedidos_validos = pedidos_en_ruta

    # Proceso de inserción con prioridades y rechazo inteligente
    unvisited = list(range(len(pedidos_validos)))
    indices_route = list(range(len(pedidos_validos)))

    while unvisited:
        min_increase = float('inf')
        best_position = None
        best_point = None

        # Buscar el mejor punto para insertar
        for point in unvisited:
            if any(np.array_equal(pedidos_validos[point].coordenadas, pedidos_validos[idx].coordenadas) for idx in indices_route):
                continue
            for i in range(current_index + 1, len(indices_route)):
                ruta_temporal = indices_route.copy()
                ruta_temporal.insert(i, point)

                # Calcular tiempos de llegada y tiempo total de la ruta
                arrival_times_temp, total_time_temp = calculate_arrival_times(
                    ruta_temporal, pedidos_validos, [10000, 10000], camion.velocidad, tiempo_total, service_time=3
                )

                # Verificar si cumple con el horizonte de tiempo
                if total_time_temp > 1020:
                    continue

                # Verificar que todos los puntos pueden atenderse antes de su vencimiento
                all_points_valid = True
                for idx_ruta, arrival_time in zip(ruta_temporal, arrival_times_temp):
                    pedido_ruta = pedidos_validos[idx_ruta]
                    if pedido_ruta.indicador == 0:
                        expiration_time_ruta = pedido_ruta.minuto_llegada + tiempo_limite
                        if arrival_time > expiration_time_ruta:
                            all_points_valid = False
                            break

                if not all_points_valid:
                    continue

                # Calcular incremento en tiempo
                increase = total_time_temp - tiempo_total

                # Rechazo para "Pick-ups"
                if (pedidos_validos[point].indicador == 1 and
                        increase > parametros["max_aumento_distancia"] * (tiempo_total / parametros["tiempo_necesario_pick_up"]) and
                        tiempo_total < parametros["tiempo_necesario_pick_up"]):
                    continue

                # Elegir este punto si el incremento es el menor
                if increase < min_increase:
                    min_increase = increase
                    best_position = i
                    best_point = point
                    best_total_time = total_time_temp
                    best_arrival_times = arrival_times_temp

        # Si se encuentra un punto para insertar
        if best_point is not None:
            indices_route.insert(best_position, best_point)
            unvisited.remove(best_point)
            tiempo_total = best_total_time
            arrival_times = best_arrival_times
        else:
            break

    # Construir la ruta final
    ruta_final_coords = [[10000, 10000]] + [pedidos_validos[idx].coordenadas for idx in indices_route] + [[10000, 10000]]

    return ruta_final_coords


def calculate_arrival_times_adapted(ruta, depot, camion_velocidad, minuto_actual, service_time=3):
    arrival_times = []
    current_time = minuto_actual
    current_location = depot
    
    # Para cada punto en la ruta
    for punto in ruta:
        next_location = punto
        
        # Calcular el tiempo de viaje al siguiente punto
        distance = manhattan_distance(current_location, next_location)
        travel_time = distance / camion_velocidad

        # Tiempo de llegada al siguiente punto
        arrival_time = current_time + travel_time

        # Actualizar el tiempo actual sumando el tiempo de viaje y el tiempo de atención
        current_time = arrival_time + service_time

        # Almacenar el tiempo de llegada (antes del servicio)
        arrival_times.append(arrival_time)

        # Actualizar la ubicación actual
        current_location = next_location

    # Finalmente, regresar al depósito
    distance = manhattan_distance(current_location, depot)
    travel_time = distance / camion_velocidad
    current_time += travel_time  # Sumar tiempo para regresar al depósito

    return arrival_times, current_time  # Retorna los tiempos de llegada y el tiempo total









# Parámetros de la simulación (ajustables por Optuna)
parametros_ventana_1 = {'min_pedidos_salida': 8, 'porcentaje_reduccion_distancia': 69, 'max_puntos_eliminados': 18, 'x_minutos': 36, 'limite_area1': 130, 'limite_area2': 263, 'peso_min_pedidos': 0.8539602391541146, 'peso_ventana_tiempo': 1.4716156151156219, 'umbral_salida': 1.2899961479169701, 'tiempo_minimo_pickup': 22, 'max_aumento_distancia': 13, 'tiempo_necesario_pick_up': 1338, 'tiempo_restante_max': 190, 'max_aumento_distancia_delivery': 1016}
parametros_ventana_2 = {'min_pedidos_salida': 5, 'porcentaje_reduccion_distancia': 34, 'max_puntos_eliminados': 9, 'x_minutos': 16, 'limite_area1': 148, 'limite_area2': 184, 'peso_min_pedidos': 1.6641134475979422, 'peso_ventana_tiempo': 1.588743965974094, 'umbral_salida': 1.4367916479682685, 'tiempo_minimo_pickup': 43, 'max_aumento_distancia': 8, 'tiempo_necesario_pick_up': 836, 'tiempo_restante_max': 11, 'max_aumento_distancia_delivery': 28}
parametros_ventana_3 = {'min_pedidos_salida': 1, 'porcentaje_reduccion_distancia': 33, 'max_puntos_eliminados': 18, 'x_minutos': 15, 'limite_area1': 122, 'limite_area2': 225, 'peso_min_pedidos': 0.5389202543851898, 'peso_ventana_tiempo': 1.369371705453108, 'umbral_salida': 1.4795958635544573, 'tiempo_minimo_pickup': 43, 'max_aumento_distancia': 19, 'tiempo_necesario_pick_up': 1211, 'tiempo_restante_max': 96, 'max_aumento_distancia_delivery': 556}

# Cargar los datos de la simulación desde archivos pickle
with open("Instancia Tipo IV/scen_points_sample.pkl", 'rb') as f:
    points = pickle.load(f)[3]  # Seleccionar la primera simulación para este ejemplo
with open('Instancia Tipo IV/scen_arrivals_sample.pkl', 'rb') as f:
    llegadas = pickle.load(f)[3]
with open('Instancia Tipo IV/scen_indicador_sample.pkl', 'rb') as f:
    indicadores = pickle.load(f)[3]

arribos_por_minuto = procesar_tiempos([llegadas], division_minutos=60)[0]
simulacion = EstadoSimulacion(minuto_inicial=520, puntos=points, indicadores=indicadores, arribos_por_minuto=arribos_por_minuto)

# Inicializar los camiones
camiones = [
    Camion(id=1, tiempo_inicial=0),
    Camion(id=2, tiempo_inicial=0),
    Camion(id=3, tiempo_inicial=0)
]

simular_minuto_a_minuto(simulacion, camiones, parametros_ventana_1, parametros_ventana_2, parametros_ventana_3)

registrar_tiempos_delivery(simulacion, camiones)

# Llamar a la función para crear el GIF
#crear_gif_con_movimiento_camiones(simulacion)
